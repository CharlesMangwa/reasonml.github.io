---
title: Interop√©rabilit√©
order: 1
---

## Dumper du JavaScript en plein milieu de votre code Reason

Si vous ne faites que tester des choses, cela peut √™tre tr√®s agr√©able, mais vous avez √©galement toute l'ins√©curit√© du code JavaScript üòÑ.

```ocaml
Js.log "ceci est reason";
[%%bs.raw {|
console.log('voici un peu de javascript pour vous');
|}];
```

> `{|` et `|}` sont les d√©limiteurs de strings sur plusieurs lignes en OCaml. Vous pouvez √©galement mettre un tag √† l'int√©rieur, par exemple`{something|`, qui recerchera une correspondance `|something}` pour se fermer.

Et voici le JavaScript qui en r√©sulte :

```javascript
// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';
console.log("ceci est reason");
console.log('voici un peu de javascript pour vous'');
```

## Dumper dans du JavaScript et rendre le tout accessible depuis Reason

Que faire si vous voulez une valeur qui peut √™tre utilis√©e √† partir de votre code Reason ?

```ocaml
Js.log "ceci est reason";
let x = [%bs.raw {| 'voici une string depuis javascript' |}];
Js.log (x ^ " en territoire reason"); /* ^ est l'op√©rateur pour la concat√©nation de strings */
```

Maintenant vous devez peut-√™tre vous demander "mais qu'elle est cette sorcellerie ?". Comment OCaml sait-il que `x` est une string ? Il n'en sait rien. Le type de `x` dans ce code est un type magique qui s'unifiera avec n'importe quoi ! Voil√† pourquoi cette m√©thode est tr√®s dangereuse et peut avoir des effets en cascade dans l'algorithme d'inf√©rence de types d'OCaml.

```ocaml
let y = [%bs.raw {| 'quelque chose' |}];
Js.log ("une string" ^ y, 10 + y);
/* danger !! ocaml ne vous emp√™chera pas d'utiliser y comme √©tant 2 types totalement diff√©rents */
```

Pour pallier cela, vous devez **toujours** pr√©cisez le type concret du r√©sultat de `bs.raw`.

```ocaml
let x: string = [%bs.raw {| 'bien typ√©' |}];
Js.log (x ^ " en territoire reason");
/* ocaml g√©n√©rera une erreur si vous essayez d'utiliser x comme √©tant autre chose qu'une string */
```

Et voici le r√©sulat !

```javascript
// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';
console.log("ceci est reason");
var x = ( 'voici une string depuis javascript' );
console.log(x + " en territoire reason");
var y = ( 'quelque chose' );
console.log(/* tuple */[
      "une string" + y,
      10 + y | 0
    ]);
var x$1 = ( 'bien typ√©' );
console.log(x$1 + " en territoire reason");
```

> La diff√©rence entre les 2 `%%` de la section pr√©c√©dente et le seul `%` de celle-ci est importante ! `[%%something ...]` est un "point d'extension" OCaml qui repr√©sente une instruction de *haut niveau* (il ne peut appara√Ætre √† l'int√©rieur d'une fonction ou d'une valeur, par exemple). `[%something ...]` est un point d'extension qui repr√©sente une *expression* et peut √™tre mis √† peu pr√®s n'importe o√π, mais assurez-vous que le JavaScript que vous avez mis √† l'int√©rieur soit effectivement une expression ! Par exemple : ne placez pas un point-virgule apr√®s, ou vous obtiendrez une erreur de syntaxe lorsque vous essaierez d'ex√©cuter le JavaScript r√©sultant.

## Dumper dans une fonction & passer des valeurs

Nous aurons besoin de quelques connaissances sur la repr√©sentation du runtime de BuckleScript de diff√©rentes valeurs afin que cela fonctionne.

- les `strings` sont des strings, `ints` and `floats` sont juste des nombres
- un [Array](/guide/language/data-types/#array) est une liste de longueur fixe mutable en OCaml, et est repr√©sent√©e sous la forme d'un array simple en JavaScript.
- une [List](/guide/language/data-types/#linked-list) est une liste immutable li√©e de style fonctionnel et est clairement la solution la plus idiomatique √† utiliser dans la majorit√© des cas. Cependant sa repr√©sentation est plus compliqu√©e (essayez `Js.log [1,2,3,4]` pour vous en rendre compte). √Ä cause de cela, il est conseill√© de convertir en et depuis des `Arrays` lorsqu'on communique avec JavaScript, via `Array.of_list` et `Array.to_list`.
- Si vous voulez approfondir le sujet, il existe une liste exhaustive [dans le manuel de BuckleScript](https://github.com/bucklescript/bucklescript/wiki/Runtime-representation).

En sachant cela, nous pouvons √©crire une fonction en JavaScript qui accepte juste un array et renvoie un number, sans trop de probl√®mes.

```ocaml
let jsCalculate: array int => int => int = [%bs.raw {|
 function (numbers, scaleFactor) {
   var result = 0;
   numbers.forEach(number => {
     result += number;
   });
   return result * scaleFactor;
 }
|}];
let calculate numbers scaleFactor =>
  jsCalculate (Array.of_list numbers) scaleFactor;
Js.log (calculate [1,2,3] 10); /* -> 60 */
```

Bien s√ªr, cette fonction que nous avons √©crit en JavaScript pourrait √™tre port√©e en Reason sans trop de tracas.

**Souvenez-vous** que c'est une *porte de secours* qui est tr√®s utile pour apprendre afin que vous puissiez vous faire la main rapidement et construire quelque chose, mais c'est un bon exercice que de revenir sur ses pas et r√©√©crire le tout en un beau code Reason bien typ√© comme il faut.

J'ai rencontr√© pas mal de bugs √† cause du JavaScript brut que j'ai ajout√© pour gagner du temps √† la base üòÖ.

## S'installer et se discipliner sur certains points

Jusqu'√† maintenant nous avons utilis√© `bs.raw`, ce qui est un moyen tr√®s rapide de proc√©der mais qui *n'est pas* adapt√© √† la production.

Mais que faire si nous avons besoin d'appeler une fonction qui est en JavaScript ? Ce qui est chose n√©cessaire pour interagir avec le DOM ou utiliser des nodes modules. Dans BuckleScript, vous utilisez une d√©claration externe ([docs](http://bucklescript.github.io/bucklescript/Manual.html#_binding_to_simple_js_functions_values)).

R√©cup√©rer une valeur et une fonction sont deux choses assez simples :

```ocaml
external pi: float = "Math.PI" [@@bs.val];
let tau = pi *. 2.0;
external alert: string => void = "alert" [@@bs.val];
alert "hello";
```

Mais que se passe-t-il lorsque nous voulons quelque chose de plus compliqu√© ? Voici comment nous appellerions `getContext` depuis le canvas d'un noeud du  DOM :


```ocaml
type canvas;
type context;
/* nous laissons ces types abstraits, parce que
 * nous n'allons pas les utiliser directement */
external getContext: canvas => string => context = "" [@@bs.send];
let myCanvas: canvas = [%bs.raw {| document.getElementById("mycanvas") |}];
let ctx = getContext myCanvas "2d";
```

Alors, voyons voir ce qu'il se passe. Nous avons cr√©√© des types abstraits pour le canvas du noeud du DOM et l'objet RenderingContext associ√©.

Nous avons ensuite cr√©√© une fonction `getContext`, mais au lieu d'utiliser `@@bs.val` nous avons employ√© `@@bs.send`, et  utilis√© une string vide pour le texte de l'external. `@@bs.send` signifie "nous appelons une m√©thode sur le premier argument", qui dans ce cas est le canevas. BuckleScript traduira cela par `theFirstArgument.getContext(theSecondArgument, ...)`.

Et la string vide signifie "le nom js est le m√™me que le nom que nous donnons √† l'external ici en territoire BuckleScript", `getContext` dans le cas d'esp√®ce. Si nous voulions le nommer diff√©remment (`getRenderingContex` par exemple), nous devrions fournir la string `"getContext"` afin que BuckleScript appelle la bonne fonction.

Ajoutons une autre fonction pour rendre les choses un peu plus int√©ressantes.

```ocaml
external fillRect: context => float => float => float => float => unit = "" [@@bs.send];
```

Et maintenant nous pouvons dessiner quelque chose !

```ocaml
fillRect ctx 0.0 0.0 100.0 100.0;
```

Ce n'est pas grand chose, mais ajouter d'autres m√©thodes canvas est assez similaire, et l√† vous pouvez commencer √† faire des choses [tr√®s amusantes](https://twitter.com/jaredforsyth/status/871062358076030976).

Du coup √† quoi ressemble le JavaScript compil√© ?

```javascript
'use strict';
var tau = Math.PI * 2.0;
alert("hello");
var myCanvas = ( document.getElementById("mycanvas") );
var ctx = myCanvas.getContext("2d");
ctx.fillRect(0.0, 0.0, 100.0, 100.0);
```

Hou la la ! Vous avez vu comment BuckleScript vient de simplifier notre variable `pi` pour nous ? Et le r√©sultat ressemble quasiment √† ce qu'on aurait pu √©crire √† la main.
