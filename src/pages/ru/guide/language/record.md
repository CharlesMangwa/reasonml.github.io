---
title: Запись
order: 60
---

Записи (records) походи на JavaScript объекты, но имеют отличия:

- они легче
- неизменяемы по умолчанию
- имеют фиксированные имена и типы полей
- очень быстрые
- очень удобно типизируются

### Использование

Тип (обязательный):

```reason
type person = {
  age: int,
  name: string
};
```

Значение (значение будет выведено как тип `person`):

```reason
let me = {
  age: 5,
  name: "Big Reason"
};
```

Доступ к полям (знакомая нотация с точкой):

```reason
let name = me.name;
```

#### Записи нуждаются в явном определении


Если вы просто напишите `{age: 5, name: "Baby Reason"}` без явного указания типа выше,
то система типов выдаст ошибку. Если определение типа находится в другом файле, то вам
нужно явно указать его:

```reason
/* School.re */

type person = {age: int, name: string};
```

```reason
/* example.re */

let me: School.person = {age: 20, name: "Big Reason"};
/* or */
let me = School.{age: 20, name: "Big Reason"};
/* or */
let me = {School.age: 20, name: "Big Reason"};
```

Каждый из трех вариантов говорит "определение типа этой записи есть в файле School.re".
Первый вариант является более предпочтительным.

#### Неизменяемые обновления

Новые записи могут быть созданы из старых с помощью оператора `...`. Оригинальная запись не
будет изменена.

```reason
let meNextYear = {...me, age: me.age + 1};
```

Эти операции очень эффективны! Попробуйте их в [песочнице](/try) и посмотрите во что они
компилируются.

**Важно**: таким образом нельзя добавить новые поля, так как форма записи фиксирована.

#### Изменяемые обновления

Поля записей могут быть помечены как изменяемые. Это позволяет обновлять их на месте с
помощью оператора `=`.

```reason
type person = {
  name: string,
  mutable age: int
};
let baby = {name: "Baby Reason", age: 5};
baby.age = baby.age + 1; /* изменит `baby`. С днем рождения! */
```

### Краткий синтаксис

Чтобы уменьшить избыточность, мы предоставляем **мнемоническое сокращение (punning)** для
типов и
значений записей. Вы можете использовать это, когда имя поля записи совпадает с именем
значения/типа.

```reason
type horsePower = {power: int, metric: bool};

let metric = true;
let someHorsePower = {power: 10, metric};
/* то же самое, что и {power: 10, metric: metric}; */

type car = {name: string, horsePower};
/* то же самое, что и тип {name: string, horsePower: horsePower}; */
```

**Этот способ не работает для случая с одним полем в записи**! `{foo}` не делает то, что
вы ожидаете (это блок, возвращающий `foo`).

### Советы и трюки

#### Взаимодействие с JavaScript

Если вы работаете с JavaScript, то синтаксис записей и операции над ними будут вас знакомы.
И у вас может возникнуть соблазн взаимодействовать с JS путем конвертации объектов JS в
записи и наоборот. Это нормально, но есть **лучший спобос сделать это без потерь в
производительности**!
Подробнее [тут](https://bucklescript.github.io/bucklescript/Manual.html#_binding_to_js_objects) о **[Reason объектах](../../guide/language/object)**. Вот пример объекта:

```reason
type payload = Js.t {
    .
    name: string
};
external sendQuery: payload => unit = "sendQuery" [@@bs.module "myAjaxLibrary"];
sendQuery {"name": "Reason"};
```

Обратите внимание на точку в определении. Это нотация типа объекта, который не имеет ничего
общего с записью! Объекты будут описаны в последующих разделах.

#### Типы записей выводятся из полей

Вы **не можете** сказать "Я хочу, чтобы эта функция принимала любую запись как аргумент,
если в этой записи есть поле `age`". Следующий код работает, но не так как ожидается:

```reason
type person = {age: int, name: string};
type monster = {age: int, hasTentacles: bool};

let getAge entity => entity.age;
```

Последняя строка будет использована для выведения типа и покажет, что параметр
`entity` должен быть типа `monster`. Поэтому такой код упадет:

```reason
let kraken = {age: 9999, hasTentacles: true};
let me = {age: 5, name: "Baby Reason"};

getAge kraken;
getAge me;
```

Система типов будет ругаться на то, что `me` имеет тип `person`, и что функция `getAge`
работает только с `monster`. Если вам нужны подобного рода возможности, то используйте
объекты.

### Проектные решения

После прочтения ограничений в предыдущих разделах, и если вы ранее работали с
динамическими языками, вам может быть интересно, почему лучше использовать запись,
вместо объекта, поскольку первая требует явного указания типа и не позволяет передавать
записи с одинаковым полем в одну и ту же функцию.

1. Дело в том, что большую часть времени форма структуры данных в вашей программе
фиксирована. А если нет, то скорее всего удобнее использовать комбинацию вариантов
(описаны далее) + запись\*.

2. Так как поля записей фиксированы, то в JS они компилируются в массив (посмотрите в
песочнице). В нативном коде они компилируются в область памяти, где доступ к полю
выполняется в **две операции**: поиск + доступ. Старые добрые времена, когда люди измеряли
в наносекундах.

3. И наконец, так как типы записей находятся путем поиска явного указания типа (мы
называем это "номинальной типизацией"), то ошибки типов обычно выглядят лучше, чем в
другом случае ("структурное типизирование", как в кортежах). Это делает рефакторинг проще.
Изменение полей типа записи позволяет компилятору знать, что это все та же запись, только
неправильно используемая в нескольких местах. В противном случае, было бы трудно сказать
где запись используется неправильно.

\* И мы не просто ищем отговорки! Reason объекты поддерживают эти фичи.
