---
title: Кортеж
order: 50
---

Кортежи (tuple) являются:

- немутабельными
- упорядоченными
- фиксированного размера, заданного во время создания
- гетерогенными (могут содержать значения разных типов)

```reason
let ageAndName = (24, "Lil' Reason");
let my3dCoordinates = (20.0, 30.5, 100.0);
```

Кортежи-типы могут быть использованы в аннотациях. Кортежи-типы визуально напоминают кортежи-значения.

```reason
let ageAndName: (int, string) = (24, "Lil' Reason");
/* псевдоним кортежа */
type coord3d = (float, float, float);
let my3dCoordinates: coord3d = (20.0, 30.5, 100.0);
```

**Важно**: не бывает кортежа размера 1. Это просто значение.

### Использование

Стандартная библиотека предоставляет функции `fst` и `snd` ([тут](/api/Pervasives.html), под "Pair
operations"), удобные для того, чтобы получить элементы кортежа длинны 2. В основном вы используете
деструктурирование для получения значений кортежа:

```reason
let (_, y, _) = my3dCoordinates; /* теперь у вас есть значение y */
```

Символ `_` означает, что вы игнорируете остальные элементы.

Кортежи нельзя менять, вы можете создавать новые, деструктурируя старые.

### Советы и трюки

Кортежи удобно использовать когда нужно передать или вернуть несколько значений без особых церемоний.
Например, чтобы вернуть несколько значений:

```reason
let getCenterCoordinates () => {
  let x = doSomeOperationsHere ();
  let y = doSomeMoreOperationsHere ();
  (x, y)
};
```

Или паттерн-матчинг для всех возможных вариантов

```reason
switch (isWindowOpen, isDoorOpen) { /* кортеж размера 2 */
| (true, true) => ...
| (true, false) => ...
| (false, true) => ...
| (false, false) => ...
}
```

Старайтесь использовать кортежи **локально**. Для структуры данных, которая живет долго и передается в
различные функции предпочтите **запись (record)**, которая имеет именованные поля.

Кортежи иногда называют "типом-произведением", и `(string, int)` записывается как `string * int`
В некоторых местах. Идея в том, что кортеж является "декартовым произведением". Представьте себе 2х мерную
плоскость, на X оси которой `string`, а на Y оси `int`.

Комбинация кортежа и `switch` очень мощная и лаконичная и позволяет **избегать целой категории ошибок**.
Вместе они часто перечисляют все возможные комбинации значение. Кортеж типа `(bool, bool)` действительно
имеет `2 * 2 = 4` возможных вариации. И система типов попросит покрыть все 4. Это отлично ложится на
рефакторинг. Вместо того, чтобы добавлять if-else для определенных значение, вы можете просто добавлять
еще одну ветку в `switch`

### Дизайн решения


Существование Tuple может показаться странным для тех, кто приходит из нетипизированных языков. "Почему бы просто не использовать список / массив?"

Система типов не всесильна, и не должна такой быть. Необходимы некоторые вкусовые компромиссы для того,
чтобы держать язык простым, производительным (компиляция и работа) и простым для понимания. Reason списки
более гибки в плане размера. Их можно соединять, разрезать и так далее. В замен они должны быть гомогенными
(содержать только один тип данных). И случайный доступ по индексу может быть не всегда возможным\*.
Кортежи, с другой стороны, с помощью фиксированного размера, являются более быстрыми, дают системе типов
свободу действие для отслеживания всех элементов и гарантируют безопасный доступ. В общем вы заметите
несколько выдающихся компромиссов в системе типов: поля записей фиксированы, но могут быть гетерогенны,
а поля словаря (map) могут быть гибкими, но гомогенными. И так далее.

Кортеж типизирован "структурно". Это значит, что даже если вы не укажите типы явно, компилятор все равно
выведет их из содержимого, использования и так далее. До тех пор пока декларация и использования выведеных
типов совпадают, все отлично!

\* Дело не в том, что система типов не может принять гетерогенность динамических списков. Она на самом деле
может. Но использование такой функциональности ухудшает как начальное изучение, так и понимание кода.
Просто потому, что типы могут такое сделать, не всегда полезно вносить такую сложность.
