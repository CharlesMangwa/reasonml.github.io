---
title: Мутации
order: 140
---

Reason имеет широкую поддержку императивного программирования. Обычно вы не должны
использовать подобный подход, кроме тех случаев, когда нужно сделать код более
производительным.

### Изменение let привязки

Сами let привязки неизменяемы, но вы можете обернуть значение в `ref`, который похож
на коробку, в которой можно менять значение:

```reason
let foo = ref 5;
```

### Использование

Значение из `ref` можно получить используя оператор `!`:

```
let five = !foo; /* 5 */
```

Установить новое значение внутри `foo`:

```
foo := 6;
```

Заметьте, что предыдущая привязка `five` остается равной `5`, так как значение было
извлечено из `ref`, но не сам `ref`.

### Советы и трюки

`ref` на самом деле не специальная фича! Это просто сахар для
[предопределенной изменяемой записи `ref`](/api/Pervasives.html#TYPEref) в станратной
библиотеке. Выглядит она так:

```reason
let foo = {contents: 5};
let five = foo.contents;
foo.contents = 5;
```

Прежде чем использовать `ref`, вспомните, что можете получить легкие локальные "мутации"
перекрывая let привязки:

```reason
let foo = 10;
let foo = someCondition ? foo + 5 : foo;
print_int foo; /* either 15 or 10 */
```
