---
title: Let привязка
order: 10
---

let привязка (let binding) в других языках называется декларацией/присваиванием переменной.
`let`дает имена значениям. Они могут быть видимы и используемы кодом ниже.

```reason
let greeting = "hello!";
let score = 10;
let newScore = 10 + score;
...
```

### Блочная область видимости

Область видимости переменных может быть ограничена при помощи `{}`.

```reason
if (displayGreeting) {
  let message = "Вам нравится эта документация?";
  print_endline message;
};
/* `message` не видима здесь! */
```

### Привязки неизменяемы

Как только привязка начала ссылаться на значение, она не может ссылаться на что либо еще (кроме случаем, когда
она явно содержит изменяемое значение, о котором будет сказано позже). Однако, вы можете создать новую привязку
с тем же самым именем, которое *закроет* предыдущую привязку. И начиная с этого момента привязка будет ссылаться
на новое значение.

```reason
let message = "hello";
print_endline message; /* Выведет "hello" */
let message = "bye";
print_endline message; /* Выведет "bye" */
```

### Советы и трюки

Так как область видимости ограничена `{}`, вы можете создавать анонимные переменные:

```reason
let message = {
  let part1 = "hello";
  let part2 = "world";
  part1 ^ " " ^ part2
};
/* `part1` и `part2` недоступны здесь! */
```

Это позволяет не допустить использования переменных ниже в коде.

### Дизайн решения

Reason использует OCaml под капотом. Let биндинг в OCaml выглядит так:

```ocaml
let a = 1 in
let b = 2 in
a + b
```

Что концептуально может быть прочитано как:

```ocaml
let a = 1 in
  let b = 2 in
    a + b
```

Что может напомнить вам:

```reason
/* Reason синтаксис */
fun a =>
  fun b =>
    a + b;
```

Не смотря на то, что это разные вещи, вы можете видеть, что `let` является просто выражением! В Reason мы
заменили `in` на `;` для сходства с JS, но не забывайте, что внутри это выражение.
