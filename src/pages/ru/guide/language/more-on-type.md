---
title: Больше о типах
order: 120
---

### Аргументы типа

Типы могут принимать параметры, как шаблоны в других языках. Это как если бы тип был функцией,
которая принимает аргументы и возвращает новый тип. Параметр **обязан** начинаться с  `'`.

Такие типы используются для уменьшения дублирования кода. Без них:

```reason
/* Кортеж из трех элементов */
type intCoordinates = (int, int, int);
type floatCoordinates = (float, float, float);

let buddy: intCoordinates = (10, 20, 20);
```

С ними:

```reason
type coordinates 'a = ('a, 'a, 'a);

/* применить "функцию-тип" и вернуть тип (int, int, int) */
type intCoordinatesAlias = coordinates int;
let buddy: intCoordinatesAlias = (10, 20, 20);

/* можно записать одной строкой */
let buddy: coordinates float = (10.5, 20.5, 20.5);
```

На практике типы будут выведены. Потому более простая версия:

```reason
let buddy = (10, 20, 20);
```

Система типов поймет, что это `(int, int, int)`. Ничего более писать не нужно.

Типы с аргументами используются повсеместно.

```reason
/* выводится как `list string` */
let greetings = ["hello", "world", "how are you"];
```

Если бы типы не могли принимать параметры, то стандартной библиотеке пришлось бы определять
отдельные методы для типов  `listOfString`, `listOfInt`, `listOfTuplesOfInt`, и так далее

Типы могут принимать несколько аргументов и комбинироваться:

```reason
type result 'a 'b =
| Ok 'a
| Error 'b;

type myPayload = {data: string};

type myPayloadResults 'errorType = list (result myPayload 'errorType);

let payloadResults: myPayloadResults string = [
  Ok {data: "hi"},
  Ok {data: "bye"},
  Error "Something wrong happened!"
];
```

### Взаимно рекурсивные типы

Как и функции типы могут быть рекурсивными при помощи `and`:

```reason
type student = {taughtBy: teacher}
and teacher = {students: list student};
```

**Важно** отсутствие точки запятой на первой строке.

### Проектные решения

Система типов позволяющая типы с аргументами, по сути предоставляет функции для оперирования
типами. `list int` это функция уровня типов `list`, которая принимает `int` тип, и возвращает
новый тип, который можно использовать в других местах. В других языках такое называется
 "генериками (generics)". Например, `ArrayList<Integer>` в Java.

[Принцип наименьшей можности](https://en.wikipedia.org/wiki/Rule_of_least_power) применяются,
когда вы просто "пытаетесь заставить все работать".
Если проблемная область позволяет, определенно выберите наименее абстрактное (наиболее
конкретное) решение, чтобы решение было быстрее достигнуто и у него было меньше неустойчивых
направлений, которые вам нужно было бы пройти. Например, предпочитайте типы над данными
свободной формы, предпочитайте конфигурацию, управляемую данными, за счет завершения функций
вызовов, предпочитайте вызовы функций над макросами, предпочитаете макросы над копированием
кода. Когда вы ограничиваете свой домен и возможности, становится легче анализировать

Когда система типов является всеобъемлющим аспектом вашей программы, мы должны убедиться,
что оставляем достаточно возможностей, чтобы не ограничивать вашу выразительность.
Без "функций типа", у вас будет довольно много повторений. Например, `listOfInt`,
`listOfString`, `listOfArrayOfFloat`, плюс функции для работы с ними. Однако, убедитесь, что
не злоупотребляете этой фичей. Иногда это нормально — написать _немного_ дублирующего кода,
убирая необходимость в абстракциях.

