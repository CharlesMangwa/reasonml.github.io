---
title: Список и Массив
order: 80
---

### Список (List)

Списки являются:

- гомогенными
- немутабельными
- быстрыми для добавления элемента в начало

```reason
let myList = [1, 2, 3];
```

Reason списки являются простыми односвязанными списками.

#### Использование

Вы должны использовать список из-за возможности изменения размера, быстрого добавления
в начало и быстрого разделения на несколько списков. При том, что все операции
немутабельны.

Стандартная библиотека предоставляет [модуль List](/api/List.html) (и его аналог с
помеченными аргументами, `ListLabels`).

##### Немутабельное добавление в начало

Используйте spread синтаксис, который внутри `List.cons`:

```reason
let myList = [1, 2, 3];
let anotherList = [0, ...myList];
```

`myList` не изменился. `anotherList` теперь `[0, 1, 2, 3]`. Это эффективное
(константное время, не линейное). Три последних элемента `anotherList` разделены с
`myList`!

**Заметьте, что `[a, ...b, ...c]` синтаксически ошибочно**. Мы не поддерживаем
подобные операции для списка. Это была бы линейная операция (`O(b)`), так как каждый
элемент b был бы по одному добавлен в `c`. Используйте `List.concat` для этого.

Изменение определенного элемента в середине списка не рекомендуется, так как
затраты на производительность будут линейны (`O(n)`).

##### Доступ

`switch` (описанный в [секции про паттер-матчинг](../../guide/language/pattern-matching))
является обычным способом доступа к значениям списка:

```
let message = switch myList {
| [] => "This list is empty"
| [a, ...rest] => "The head of the list is the string " ^ a
}
```

Для доступа к конкретному элементу используйте `List.nth`.

#### Советы и трюки

Вы можете без проблем объявлять множество пустых списков. Как рассказано в
[секции про вариант для списка](../../guide/language/variant#list), пустой список — это
конструктор варианта без аргумента, и компилируется в целое число. Так что нет
дополнительных потерь.

Для того, чтобы понять, как добавление может быть немутабельным и в тоже время
иметь константное `O(1)` время посмотрите [внутреннюю реализацию списка](../../guide/language/variant#list).

#### Проектные решения

В будущем мы, возможно, представит структуру данных, похожую на список, которая
немутабельна, имеет изменяемый размер и поддерживает быстрые операции, как например
[Immutable-re](https://github.com/facebookincubator/immutable-re) (пока в работе).

### Массив

Массивы как списки, кроме того, что они:

- изменяемы
- имеют быстрый произвольный доступ
- фиксированного размера в нативном коде (в JS так же изменяемого размера)

Для определения используются `[|` и `|]`.

```reason
let myArray = [|"hello", "world", "how are you"|];
```

#### Использование

Модули стандартной библиотеки [Array](/api/Array.html) и [ArrayLabel](/api/ArrayLabels.html).
Для компиляции в JS вы можете использовать [Js.Array](https://bucklescript.github.io/bucklescript/api/Js.Array.html) привязки.

Доступ и изменение полей происходят так:

```reason
let myArray = [|"hello", "world", "how are you"|];

let world = myArray.(1); /* "hello" */

myArray.(0) = "hey";

/* теперь [|"hey", "world", "how are you"|] */
```

Этот способ лишь синтаксический сахар для `Array.get`/`Array.set`.

#### Советы и трюки

Если вы компилируете код в JavaScript, то массивы Reason прямо ложатся на массивы
JavaScript и наоборот. То есть даже учитывая, что массивы в нативном коде имеют
фиксированный размер, вы все еще можете использовать `Js.Array` для их изменения.
Это норма!
