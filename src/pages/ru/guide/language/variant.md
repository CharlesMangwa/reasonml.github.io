---
title: Вариант!
order: 70
---

Трепещите! Драгоценность среди структур данных Reason!

Большая часть структур данных в большинстве языков об этом **и** том. Вариант позволяет
нам выразить это **или** то.

```reason
type myResponseVariant =
| Yes
| No
| PrettyMuch;

let areYouCrushingIt = Yes;
```

`Yes`, `No` и `PrettyMuch` не строки и не ссылки, а некий специальный тип. Они называются
"конструкторами" (или "тегами"). Символ `|` разделяет каждый конструктор.

**Важно**: имена конструкторов должны начинаться с заглавной буквы.

### Использование

Вместе с вариантом идет одна из важнейших фич Reason — `switch` выражение.

`switch` в Reason визуально похож на тот, который можно встретить в других языках (что
работает как большой `if/elseif/elseif...`). Оно позволяет проверять все возможные
комбинации варианта. Для использования перечислите все конструкторы варианта, который
хотите использовать, указав после `=>` и выражение для конкретного случая.

```reason
let message = switch (areYouCrushingIt) {
| No => "No worries. Keep going!"
| Yes => "Great!"
| PrettyMuch => "Nice!"
};
/* message будет "Great!" */
```

Варианты имеют огромную поддержку со стороны системы типов. Например, она выдаст ошибку,
если вы забудете покрыть один из случаем варианта, или если два случая будут
взаимозаменяемы. Обязательно прочитайте об этой конструкции и паттер-матчинге
в [последующей секции](../../guide/language/pattern-matching)!

#### Вариантам необходимо явное определение

Если вы используете вариант из другого файла, то принесите его в область видимости
как вы делаете это [для записи](../../guide/language/record#record-needs-an-explicit-definition):

```reason
/* Zoo.re */

type animal = Dog | Cat | Bird;
```

```reason
/* example.re */

let pet: Zoo.animal = Dog; /* предпочтительный способ */
/* или */
let pet = Zoo.Dog;
```

#### Аргументы конструктора

Конструкторы вариантов могут содержать дополнительные данные, разделенные пробелом.

```reason
type account =
| None
| Instagram string
| Facebook string int;
```

Здесь `Instagram` содержит `string`, а `Facebook` содержит `string` и `int`. Использование:

```reason
let myAccount = Facebook "Josh" 26;
let friendAccount = Instagram "Jenny";
```

**Заметили, что использование конструктора похоже на вызов функции**? Как если бы
 `Facebook` был функцией, принимающей два аргумента. Это не случайность, есть основания
 почему дополнительные данные называются "аргументами конструктора".

Используя `switch`, вы можете сопоставлять шаблон значению:

```reason
let greeting = switch (myAccount) {
| None => "Hi!"
| Facebook name age =>
  "Hi " ^ name ^ ", you're " ^ (string_of_int age) ^ "-year-old."
| Instagram name => "Hello " ^ name ^ "!"
}
```

#### Важные замечания

[Стандартная библиотека](/api/index.html) предоставляет два важных варианта, которые вы
будете часто встречать.

##### `option`

```reason
type option 'a = None | Some 'a;
```

Это принятый способ симулировать "нулевой" (`undefined`, `null`) тип в других языках.
Благодаря этому в Reason нет может быть значений, которые могут оказаться нулевыми.
Тип `int` всегда будет целым и никогда "`int` **или** `null` **или** `undefined`".
Если вам нужно выразить "nullable int", вы можете использовать `option int`,
чье возможное значение `None` или `Some int`. `switch` принудит проверить оба случая,
**программа на Reason не имеет ошибок связанных с null**.

##### Список `list`

```reason
type list 'a = Empty | Head 'a (list 'a);
```

_Это не настоящий тип, просто иллюстрация_

Это значит: "список, который содержит значение типа `a` (неважно что это за тип)
является или пустым списком или содержит значение + еще список".

Reason имеет синтаксический сахар `list`. `[1, 2, 3]` это эквивалент
`Head 1 (Head 2 (Head 3 Empty))`. И опять, `switch` принудит проверить все случаи,
включая `Empty` (то есть `[]`). **Это устаняет другую большую категорию багов**.

##### Другие типы, похожие на варианты

А вы знаете, что можете использовать `switch` на числах, строках и большинстве структур
данных? Попробуйте!

<!-- TODO playground link -->

### Советы и трюки

**Будте внимательны**: не путайте конструктор, который использует два аргумента с конструктором,
который использует кортеж из двух элементов:

```reason
type account =
| Facebook string int /* два аргумента */
type account2 =
| Instagram (string, int) /* один аргумент — кортеж из двух элементов  */
```
#### Варианты обязаны иметь конструкторы

Если вы пришли из нетипизированного языка, то у вас может возникнуть соблазн попробовать
`type foo = int | string`. Это невозможно в Reason. Вы должны дать каждой ветке конструктор
`type foo = Int int | String int`. Хотя обычно это считается анти-паттерном.

#### Взаимодействие с JavaScript

Этот раздел подразумевает знание
[FFI](http://bucklescript.github.io/bucklescript/Manual.html#_ffi).
Пропустите его если пока незнакомы.

Многие JS библиотеки используют функции, которые могут принимать разные типы
аргументов. В таких случаях заманчиво моделировать аргументы как варианты. Например,
представим что есть функция `myLibrary.draw` в JS, которая принимает `number` или `string`.
Вы можете сделать так

```
/* reserved for internal usage */
external draw: 'a => unit = "draw" [@@bs.module "myLibrary"];

type animal =
  | MyFloat float
  | MyString string;

let betterDraw animal =>
  switch animal {
  | MyFloat f => draw f
  | MyString s => draw s
  };
```

Но есть лучший способ! Например, просто два `external` которые компилируются в один
 JS вызов:

```
external drawFloat: float => unit = "draw" [@@bs.module "myLibrary"];
external drawString: string => unit = "draw" [@@bs.module "myLibrary"];
```

Или используйте продвинутую фичу, называемую GADT [с фантомным аргументом FFI BuckleScript](http://bucklescript.github.io/bucklescript/Manual.html#_phantom_arguments_and_ad_hoc_polymorphism). Если эти слова ничего для вас не говорят, не волнуйтесь, просто используйте
предыдущий способ.

#### Типы вариантов выводятся из имен полей

Please refer to this [record section](../../guide/language/record#record-types-are-found-by-field-name). Variants are the same: a function can't accept an arbitrary constructor shared by two different variants. Again, such feature exists, it's called a polymorphic variant. We'll talk about this in the future =).

### Проектные решения

Варианты в различных формах (полиморфные, открытые, GADT, и так далее), возможно, основная
фича таких систем типов как в Reason. Вышеупомянутый вариант `option`, например убирает
необходимость использовать nullable типы. Философски говоря, проблема состоит и множества
веток и условий. Ошибки в формировании этих условиях являются основным источником багов в
других языках. **Система типов не устраняет баги магическим образом. Она указвывает на
необработанные случаи и просить закрыть их**\*. Способность языка моделировать идею
"это или то" имеет решающее значение для этого.

Например, как сделать так, чтобы система типом могла устранить просачивание плохих данных,
полученных из инвалидного JSON? Это можно сделать если парсер будет возвращать тип
`option`, то есть `None | Some actualData`, тогда все что нужно — это обработать случай
с `None`.

К тому же вариант может значительно ускорить логику вашей программы. Возьмем кусок JS кода:

```js
let data = 'dog';
if (data === 'dog') {
  ...
} else if (data === 'cat') {
  ...
} else if (data === 'bird') {
  ...
}
```

Тут существует линейное количество проверок (`O(n)`). Сравните с подобным кодом на Reason:

```reason
type animal = Dog | Cat | Bird;
let data = Dog;
switch data {
| Dog => ...
| Cat => ...
| Bird => ...
}
```

Компилятор видит вариант и потом:

1. Превращает его в `type animal = 0 | 1 | 2`

2. Компилирует `switch` в формат с константным временем (`O(1)`).

Вы можете задаться вопросом, почему типизированные функциональные языки используются так часто для синтаксического анализа. Переключение большого дерева эффективно и безопасно - это в значительной степени лучший сценарий для использования вариантов.

<!-- TODO: playground link -->

Ваш мозг уже кипит? Варианты имеют глубокую связь с другими областями математики;
[Посмотрите тут](https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types) если интересно.

\* Всегда лучше проектировать систему так, чтобы избежать подводных камней, а не надеяться
на систему типов. Однако, в реальности, сложно сделать это для каждой проблемы. Более того
не всегда удается понять проблему полностью, чтобы спроектировать решение сразу. Система
типов позволяет внести разнообразные изменения в кодовую базу без необходимости понимать
все целиком. В связи с эти типы позволяют не затрачивать много времени на дизайн API чтобы
обойти простые ошибки, вызванные вызывающей стороной. Они уменьшают уровень абстракций,
необходимый для достижения цели, что уменьшает когнитивную нагрузку.
